<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Text Editor sam with Rob Pike - PilJin.Kwon&#39;s Private Site</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="A tutorial for the sam command language

[Rob Pike]

ABSTRACT

[!NOTE]
sam은 정규표현식을 많이 사용하는 명령 언어 (Command Language) 가 포함된 대화형 텍스트 편집기 입니다. 명령 언어는 문법적으로 ed(1) 와 유사하지만 세부 사항은 흥미롭게 다릅니다. 이 자습서에서는 명령 언어에 대해서 소개하고 화면 및 마우스 인터페이스에 대해서는 별도로 설명하지 않습니다. 9th 버전의 Blit 소프트웨어에 익숙한 사용자에게는 미리 사과 말씀과 함께 mux(9) 에 대한 sam의 유사성으로 인해 sam의 마우스 언어는 사용자가 쉽게 배울 수 있다고 가정하고 설명합니다." />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="http://localhost:1313/posts/sam/">
  <meta property="og:site_name" content="PilJin.Kwon&#39;s Private Site">
  <meta property="og:title" content="Text Editor sam with Rob Pike">
  <meta property="og:description" content="A tutorial for the sam command language [Rob Pike] ABSTRACT
[!NOTE] sam은 정규표현식을 많이 사용하는 명령 언어 (Command Language) 가 포함된 대화형 텍스트 편집기 입니다. 명령 언어는 문법적으로 ed(1) 와 유사하지만 세부 사항은 흥미롭게 다릅니다. 이 자습서에서는 명령 언어에 대해서 소개하고 화면 및 마우스 인터페이스에 대해서는 별도로 설명하지 않습니다. 9th 버전의 Blit 소프트웨어에 익숙한 사용자에게는 미리 사과 말씀과 함께 mux(9) 에 대한 sam의 유사성으로 인해 sam의 마우스 언어는 사용자가 쉽게 배울 수 있다고 가정하고 설명합니다.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-02-24T00:00:00+00:00">
    <meta property="article:tag" content="Editor">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Text Editor sam with Rob Pike">
  <meta name="twitter:description" content="A tutorial for the sam command language [Rob Pike] ABSTRACT
[!NOTE] sam은 정규표현식을 많이 사용하는 명령 언어 (Command Language) 가 포함된 대화형 텍스트 편집기 입니다. 명령 언어는 문법적으로 ed(1) 와 유사하지만 세부 사항은 흥미롭게 다릅니다. 이 자습서에서는 명령 언어에 대해서 소개하고 화면 및 마우스 인터페이스에 대해서는 별도로 설명하지 않습니다. 9th 버전의 Blit 소프트웨어에 익숙한 사용자에게는 미리 사과 말씀과 함께 mux(9) 에 대한 sam의 유사성으로 인해 sam의 마우스 언어는 사용자가 쉽게 배울 수 있다고 가정하고 설명합니다.">

        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css" media="(prefers-color-scheme: dark)"  /><script type="text/javascript"
		src="http://localhost:1313/js/MathJax.js"></script>
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script><link rel="stylesheet" href="http://localhost:1313/katex/katex.min.css ">
		<script defer src="http://localhost:1313/katex/katex.min.js"></script>
		<script defer src="http://localhost:1313/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
		</script>
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">PilJin.Kwon&#39;s Private Site</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/tags">Tags</a>
		
		
	</nav>
</header>

<main>
  <article>
    <div class="post-container">
      
      <div class="post-content">
        <div class="title">
          <h1 class="title">Text Editor sam with Rob Pike</h1>
          <div class="meta">Posted on Feb 24, 2025</div>
        </div>
        
        <section class="body">
          <h1 id="a-tutorial-for-the-sam-command-language">A tutorial for the sam command language</h1>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->
[<strong>Rob Pike</strong>]
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p><strong>ABSTRACT</strong></p>
<blockquote>
<p>[!NOTE]
sam은 정규표현식을 많이 사용하는 명령 언어 (Command Language) 가 포함된 대화형 텍스트 편집기 입니다. 명령 언어는 문법적으로 ed(1) 와 유사하지만 세부 사항은 흥미롭게 다릅니다. 이 자습서에서는 명령 언어에 대해서 소개하고 화면 및 마우스 인터페이스에 대해서는 별도로 설명하지 않습니다. 9th 버전의 Blit 소프트웨어에 익숙한 사용자에게는 미리 사과 말씀과 함께 mux(9) 에 대한 sam의 유사성으로 인해 sam의 마우스 언어는 사용자가 쉽게 배울 수 있다고 가정하고 설명합니다.</p>
<p>sam 명령 언어는 일반적으로 두 가지 환경에서 실행할 수 있습니다. 일반적인 터미널 (sam -d 를 통해) 에서 실행하는 경우와 비트맵 디스플레이와 마우스를 사용하는 명령 윈도우를 포함한 다운로드된 sam으로 실행할 수 있습니다.</p></blockquote>
<hr>
<p><strong>목차</strong></p>
<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Text">Text</a></li>
<li><a href="#Addresses">Addresses</a></li>
<li><a href="#Loops">Loops</a></li>
<li><a href="#Conditionals">Conditionals</a></li>
<li><a href="#Composition">Composition</a></li>
<li><a href="#Grouping">Grouping</a></li>
<li><a href="#Multiple-Changes">Multiple Changes</a></li>
<li><a href="#Unix">Unix</a></li>
<li><a href="#A-few-other-text-commands">A few other text commands</a></li>
<li><a href="#Files">Files</a></li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<hr>
<h1 id="introduction">Introduction</h1>
<p>이 자습서에서는 Blits 및 비트맵 디스플레이가 있는 일부 컴퓨터에서 실행되는 <code>대화형 텍스트 편집기인 sam의 명령 언어(_Command Language_)</code> 에 대해 설명 합니다. 대부분의 편집 작업은 마우스 기반의 편집 기능으로 충분하며 사용법과 학습 또한 매우 쉽습니다.</p>
<p>하지만, <code>명령 언어</code> 는 특히<code> 전역적인 변경 작업을 처리할 때</code> 유용한 경우가 많습니다. ed 편집기의 명령 언어와 다르게 sam 편집기의 명령 언어는 복잡하거나 반복적인 편집 작업에 적합합니다.</p>
<blockquote>
<p>[!TIP]
sam과 다른 편집기와의 가장 큰 차이점은 매우 복잡한 편집 작업을 처리할 수 있다는 점입니다.</p></blockquote>
<p>sam 의 명령 언어는 <code>sed</code> 및 <code>awk</code> 같은 프로그램을 포함해 다른 편집기에서 매끄럽게 처리하지 못하는 일부 작업을 매우 쉽게 처리할 수 있으므로, 이 자습서는 부분적으로 sam 의 텍스트 처리 방식에 대한 교과서 역할을 합니다.</p>
<p>또한, 아래의 예제는 sam 에서 마우스를 사용하는 경우는 제외하고 전적으로 <code>sam 명령 언어</code> 에 대해서만 설명합니다. 따라서, sam 을 <code>‑d</code> 플래그(옵션)로 실행하면 마우스가 없더라도 (다운로드되지 않음) 사용할 수 있으며,
본 자습서는 바로 이런 처리 방법을 기준으로 설명합니다. 하지만, ``다운로드된 sam<code>의 처리 방법과 그래픽 환경의</code>다운로드되지 않은 sam의 명령 윈도우에서 사용하는 <code>명령 언어는 완전히 동일</code> 합니다.</p>
<blockquote>
<p>[!TIP]
<strong>Unix 숙련자에게 한마디:</strong> <code>sam</code> 은 구문적으로 <code>ed</code> 와 매우 유사하지만, 개발 디자인 측면과 세부적인 의미에선 근본적이고 의도적으로 다릅니다. ed 에 대한 기존의 지식을 활용해 대체 명령의 작동 방식을 예측할 수 있겠지만, 자신이 예측한대로 수행하기 위해선
sam 의 작업 처리 방식에 대해 어느 정도 이해한 경우에만 정상적으로 작동할 것 입니다. 특히, sam 의 <strong>관용구적인 사용법엔 특별히 주의</strong> 하시길 바랍니다. sam만의 관용구적인 사용법은 명령 언어의 구현 특성으로 인해 형성됩니다. 따라서, <code>ed 의 관용구는 sam 에선 동작하지 않습니다!</code>
예를 들어, <code>1,$s/a/b/</code> 대체 명령은 매 라인마다 대체 작업을 처리하지 않고 전체 파일을 단일 처리 범위로 하나의 대체 작업만 처리합니다. 이처럼 sam 은 자신만의 고유한 관용구를 가지고 있습니다. 이 자습서 대부분의 목적은 그것을 설명해 sam 의 유창함을 교활함이 아닌 학습의 문제로 만드는 것입니다.</p></blockquote>
<p>이 자습서는 정규표현식(<em>Regular Expression</em>)에 대한 이해도와 숙련도에 따라 달라지겠지만, 전통적인 Unix 편집기에 대한 사용 경험은 많은 도움이 될 수 있습니다. ed 편집기에 익숙한 사용자를 돕기위해 ed 와 sam 의 차이점 일부를 <code>대괄호 [...] 안에 별도로 명시</code> 했습니다.
이 두 프로그램간 차이점에 대해 이해하려는 경우에만 이 부분을 읽으시길 바랍니다. 이 자습서는 <code>sam vs ed</code> 가 아니라, <strong>오직 sam에 대한 설명 문서</strong> 입니다.</p>
<blockquote>
<p>[!IMPORTANT]
<strong>명명법:</strong> sam은 <code>편집 파일의 복사본을 보관</code> 합니다. 설명상 혼동을 피하기 위해 이런 파일(_File)_에 대한 sam 내부의 복사본을 <strong>파일</strong> 이라 명명합니다. 또한, 디스크내의 영구 저장소의 실제 파일은 <strong>Unix 파일</strong> 로 명명합니다.</p></blockquote>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="text">Text</h1>
<p>우선, 편집 작업을 시작하려면 편집할 텍스트가 필요합니다. 생각할 수 있는 모든 텍스트를 사용할 수 있습니다. 본 문서에선 <em>James Gosling</em> 의 Emacs 설명서로 시작하겠습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>$ sam -d
</span></span><span style="display:flex;"><span>a
</span></span><span style="display:flex;"><span>This manual is organized in a rather haphazard manner. The first
</span></span><span style="display:flex;"><span>several sections were written hastily in an attempt to provide a
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs and to try to show
</span></span><span style="display:flex;"><span>the method in the madness that is the Emacs command structure.
</span></span><span style="display:flex;"><span>.
</span></span></code></pre></div><blockquote>
<p>[!CAUTION]
마지막 라인에 입력한 마침표 또한 sam의 <code>명령</code> 입니다.</p></blockquote>
<p>먼저, <code>sam ‑d</code> 명령으로 sam을 실행합니다. (다운로드 모드)</p>
<p><code>a</code> (<em>append</em>) 명령은 이후 입력한 내용 (<code>a</code> 명령과 마침표 명령 사이의 모든 항목) 부터, 마침표 명령 이전까지 입력한 모든 텍스트를 파일(버퍼)에 추가한 후, <code>현재텍스트</code> (점 또는 <em>dot</em> 이라고도 함)로 설정합니다.</p>
<blockquote>
<p>[!NOTE]
[ ed는 현재주소 (점, dot) 를 입력한 마지막 라인으로 설정합니다.]</p></blockquote>
<p><code>p</code> (<em>print</em>) 명령은 현재텍스트를 출력합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>p
</span></span><span style="display:flex;"><span>This manual is organized in a rather haphazard manner. The first
</span></span><span style="display:flex;"><span>several sections were written hastily in an attempt to provide a
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs and to try to show
</span></span><span style="display:flex;"><span>the method in the madness that is the Emacs command structure.
</span></span></code></pre></div><blockquote>
<p>[!NOTE]
[다시 한 번 말하지만, ed 는 현재주소 (마지막 라인) 만 출력합니다.]</p></blockquote>
<p><code>a</code> 명령은 현재텍스트 (점, dot) <strong>다음</strong> 에 텍스트를 추가합니다. <code>i</code> (<em>insert</em>) 명령은 <code>a</code> 명령과 비슷하지만 현재텍스트 <strong>앞에</strong> 텍스트를 추가합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>i
</span></span><span style="display:flex;"><span>Introduction
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>p
</span></span><span style="display:flex;"><span>Introduction
</span></span></code></pre></div><p>또한, 현재텍스트의 텍스트를 변경(대체) 하는 <code>c</code> (<em>change</em>) 명령과 삭제하는 <code>d</code> (<em>delete</em>*) 명령도 있습니다. 이후 섹션에서 설명합니다.</p>
<p>파일내의 모든 텍스트를 출력하려면 출력 (<code>p</code>) 명령에 출력할 텍스트의 범위를 지정해 실행합니다. 지금은 단지, <strong>0,$</strong> 라 말하는 것으로 충분합니다. 이것은 <strong>전체 파일에 대한 범위 주소</strong> 입니다.</p>
<blockquote>
<p>[!NOTE]
[ed 사용자라면 <code>1,$</code> 를 입력할 것입니다. 실제론 동일하지만 자세한 내용은 아래를 참조하시기 바랍니다.]</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0,$p
</span></span><span style="display:flex;"><span>Introduction
</span></span><span style="display:flex;"><span>This manual is organized in a rather haphazard manner. The first
</span></span><span style="display:flex;"><span>several sections were written hastily in an attempt to provide a
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs and to try to show
</span></span><span style="display:flex;"><span>the method in the madness that is the Emacs command structure.
</span></span></code></pre></div><p>아래에 설명할 <code>w</code> (<em>write</em>*) 명령을 제외하고, <code>p</code> 명령을 포함한 대부분의 명령들은 자신이 처리한 텍스트에 <code>점 (현재텍스트) 을 설정</code> 합니다.
따라서, <code>a</code> 명령과 <code>i</code> 명령의 경우엔 현재텍스트를 새롭게 입력한 텍스트로 설정하고, <code>p</code> 명령은 출력한 텍스트를 현재텍스트로 설정하는 방식입니다. 마찬가지로 <strong>모든 명령 (```w```` 명령은 제외) 은 기본적으로 현재텍스트에만 영향</strong> 을 미칩니다.</p>
<blockquote>
<p>[!NOTE]
[ed 와 다르게 일부 명령 (예: <code>g</code>) 은 기본적으로 전체 파일 범위로 작동합니다.]</p></blockquote>
<p>현재텍스트를 사용자가 임의로 설정할 수 있기 전까진 상황이 그다지 흥미롭진 않을 것입니다.</p>
<p>현재텍스트는 파일의 일부 라인을 명시적인 라인 주소 (번호) 로 지정하면 설정됩니다. 예를 들어, (주소) 1 은 파일내의 첫 번째 라인을 현재텍스트로 설정합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1p
</span></span><span style="display:flex;"><span>Introduction
</span></span><span style="display:flex;"><span>c
</span></span><span style="display:flex;"><span>Preamble
</span></span><span style="display:flex;"><span>.
</span></span></code></pre></div><p>두 번째로 사용한 <code>c</code> (<em>change</em>) 명령에선 별도로 현재텍스트를 설정할 필요가 없습니다. 왜냐하면, 이전 <code>p</code> 명령으로 인해 이미 현재텍스트를 대상 라인인 1번 라인 (주소) 으로 설정했기 때문입니다.</p>
<p>다음과 같이 첫 라인을 <code>d</code> (<em>delete</em>) 명령으로 완전히 삭제하는 것 또한 쉽습니다. 이후 <code>1p</code> 명령으로 인해 현재텍스트는 다시 1번 라인으로 재설정됩니다.</p>
<blockquote>
<p>[!TIP]
파일에서 라인을 삭제하면 라인 번호가 재정렬되어 변경됩니다.</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>d
</span></span><span style="display:flex;"><span>1p
</span></span><span style="display:flex;"><span>This manual is organized in a rather haphazard manner. The first
</span></span></code></pre></div><p><code>/text/</code> 형식으로 사용하는 <code>검색 명령은 현재텍스트 다음부터 검색 패턴 텍스트가 처음으로 나타나는 위치를 검색한 후, 현재텍스트로 설정</code> 합니다.</p>
<blockquote>
<p>[!NOTE]
[ed 는 검색 패턴 텍스트가 포함된 첫 번째 라인 주소를 현재주소로 설정합니다.]</p></blockquote>
<p>만약, 현재텍스트 다음 부분에 검색 패턴 텍스트를 찾을 수 없는 경우, 검색 작업은 파일 시작 부분부터 다시 검색해서 현재텍스트 위치까지 계속 순환 검색됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>/Emacs/p
</span></span><span style="display:flex;"><span>Emacs
</span></span></code></pre></div><p>타이포그래피 (<em>Typographie</em>) 로는 제대로 표현하기 어렵겠지만, 이 예제는 <code>&quot;Emacs&quot; 검색 문자열 뒤에 어떤 개행 문자나 공백 문자도 현재텍스트에는 포함되지 않습니다!!</code> 따라서, <code>p</code> 명령으로 출력하면 정확한 &ldquo;Emacs&rdquo; 문자열까지만 표시합니다.</p>
<blockquote>
<p>[!TIP]
사실, 마지막에 사용한 <code>p</code> (수정자) 명령은 생략할 수 있습니다. 왜냐하면, 검색 명령에 대한 <code>기본 수정자 명령</code> 이기 때문입니다. 그러나, <code>sam -d```` 다운로드 모드로 실행하지 않을 때의 기본적인 처리방식은 검색 텍스트를 선택한 후, 강조 표시하고 필요한 경우 해당 파일에 대한 편집 윈도우로 이동한 후, 표시하도록 처리하는 것입니다. 따라서, </code>/Emacs/``` 는 화면에 검색 텍스트의 다음 번 검색 일치를 표시합니다.</p></blockquote>
<p>예를 들어, &ldquo;haphazard&rdquo; 이란 단어를 &ldquo;thoughtless&rdquo; 로 바꾸고 싶다고 가정합니다. 여기서 사용할 명령은 지금까지와는 처리 방식이 약간 다른 <code>c</code> (<em>change</em>) 명령입니다.</p>
<p>지금까지는 텍스트를 검색한 후, 명령을 별도로 입력해 처리했습니다. 변경할 텍스트를 검색 명령 구문내에서 직접 텍스트를 지정해 변경하는 구문은 변경할 텍스트를 슬래시 문자로 또 한 번 둘러싸는 것입니다.</p>
<blockquote>
<p>[!TIP]
이런 구문 형식은 검색 명령의 구문과 동일하지만 문맥에 따라 명확하게 구별할 수 있습니다.</p></blockquote>
<p>검색 명령으로 변경할 텍스트는 <code>c</code> (또는 <code>a</code> 또는 <code>i</code>) 명령 바로 뒤에 나타나야 합니다. 이런 처리 방식을 감안해 본다면 텍스트에 대한 변경 작업이 필요할 때 손 쉽게 텍스트를 곧바로 수정할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>/haphazard/c/thoughtless/
</span></span><span style="display:flex;"><span>1p
</span></span><span style="display:flex;"><span>This manual is organized in a rather thoughtless manner. The first
</span></span></code></pre></div><blockquote>
<p>[!NOTE]
[만약 입력할 텍스트가 한 라인을 넘어갈 경우에도 항상 <code>c</code> 명령으로 텍스트를 변경할 수 있습니다.]</p></blockquote>
<p>검색 명령에 변경할 텍스트를 직접 제공하는 이런 처리 방식은 라인 단위로 처리하는 방식보다 훨씬 더 <strong>직관적</strong> 이란 것도 잘 알게 될 것입니다.</p>
<p>또한, 검색 텍스트내에서 슬래시 <code>/</code> 문자 자체를 검색하려면 백슬래시 <code>\</code> 문자를 슬래시 문자 앞에 추가해 슬래시 문자 자체를 보호합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>/Emacs/c/Emacs\\360/
</span></span><span style="display:flex;"><span>3p
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs\360 and to try to show
</span></span></code></pre></div><p>또한, 다음과 같이 검색 명령 다음에 <code>a</code> 추가 명령을 사용할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>/Emacs/a/\\360/
</span></span></code></pre></div><p>지금이 바로 마지막으로 실행했던 명령들을 실행 취소하는 <code>u</code> (<em>undo</em>) 명령을 소개하기에 적당한 곳입니다.</p>
<p>다음 예제는 마지막으로 실행했던 두 개의 명령을 순차적으로 실행 취소합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>u
</span></span><span style="display:flex;"><span>4p
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs and to try to show
</span></span><span style="display:flex;"><span>u
</span></span><span style="display:flex;"><span>3p
</span></span><span style="display:flex;"><span>This manual is organized in a rather haphazard manner. The first
</span></span></code></pre></div><p>실행 취소는 명령 백업으로만 처리 가능합니다. 즉, 이전에 사용한 <code>u</code> 명령을 다시 실행 취소하지 않습니다!</p>
<p><a href="#top">:arrow_up:</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="addresses">Addresses</h1>
<p>지금까지는 가장 단순한 형태의 주소 (라인 번호 주소) 를 살펴봤지만, 좀 더 자세히 알아보기 전에 미리 알아둬야 할 것이 있습니다.</p>
<p><code>주소</code> (<em>address</em>) 는 파일내의 <code>특정한 텍스트의 영역 (하위 문자열) 을 선택</code> 하므로, 이렇게 <code>선택한 텍스트 영역에 대한 시작과 끝을 정의</code> 해야만 합니다.</p>
<p>따라서, 라인 주소 13은 13번 라인의 처음부터 13번 라인의 끝까지를 선택한 것이고, <code>/Emacs/</code>  검색 명령은 &ldquo;Emacs&rdquo; 라는 단어의 처음부터 단어의 끝까지를 선택합니다.</p>
<p>또한, 주소는 쉼표 문자와 결합해 <code>범위 주소</code> 형태로 사용할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>13,15
</span></span></code></pre></div><p>이것은 13번 라인 시작부터 15번 라인 끝까지를 선택한 후, 현재텍스트로 설정합니다.</p>
<p>쉼표 문자에 대한 정의는 <code>쉼표 문자 왼쪽 주소를 시작 (13번 라인 시작) 으로 오른쪽 주소의 끝 (15번 라인 끝) 까지를 선택한다</code> 는 것입니다.</p>
<p>또한, 다음과 같은 몇 가지 특별한 주소 전용 문자는 유용할 수 있습니다.</p>
<p><code>.</code> (마침표) 는 현재텍스트인 점 (<em>dot</em>) 을 의미하고, <code>0</code> (0번 라인) 은 파일의 시작 부분 앞의 <code>null</code> 문자를 선택하고, <code>$</code> 는 (파일의 마지막 라인이 아님) 파일의 끝부분
다음의 <code>null</code> 문자를 선택합니다.</p>
<p>따라서, 다음과 같은 주소는</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0,13
</span></span></code></pre></div><p>사실, 파일의 첫 라인부터 13번 라인의 끝까지를 선택합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>.,$
</span></span></code></pre></div><p>여기서 사용한 주소는 현재텍스트의 처음부터 파일 끝까지를 선택하고, 따라서, 다음과 같은 주소는</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0,$
</span></span></code></pre></div><p>결과적으로 <strong>파일 전체를 선택</strong> 합니다.</p>
<blockquote>
<p>[!NOTE]
[즉, 파일내의 <code>모든 라인</code> 을 의미하는 것이 아니라, <code>파일 전체를 포함한 단일 선택 문자열로 인식</code> 합니다.]</p></blockquote>
<p>지금까지 사용한 주소는 모두 라인 번호에 대한 <strong>절대 주소</strong> 입니다. 즉, 파일내의 특정 라인 위치를 직접 나타냅니다. sam은 현재텍스트 위치에 따라 달라지는 <strong>상대 주소</strong> 를 가지고 있으며 이미 한 가지 형식을 사용했습니다.</p>
<p>&ldquo;Emacs&rdquo; 를 검색할 때, 현재텍스트를 기준으로 검색되는 방향을 다르게 검색할 수 있습니다. 만약, 현재텍스트 이전에 위치한 첫 번째 검색을 원한다면 어떻게 처리해야 할까요?</p>
<p>검색 명령 앞에 빼기 (<code>-</code>) 문자를 추가하면 현재텍스트를 기준으로 역방향으로 검색합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>-/Emacs/
</span></span></code></pre></div><p>사실, 순방향 검색을 위한 정식 검색 명령 구문은 다음과 같습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>+/Emacs/
</span></span></code></pre></div><p>그러나, 더하기 문자는 검색 명령의 <code>기본값</code> 이므로, 명시적으로 사용하지 않습니다. 단지, 검색 방향을 보다 명확하게 지정하기 위해 명시적으로 검색 방향을 지정한 예제는 다음과 같습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0+/Emacs/
</span></span></code></pre></div><p>이 검색 명령은 파일의 처음부터 &ldquo;Emacs&rdquo; 패턴 문자열을 검색한 후, 첫 번째 검색 일치한 항목을 현재텍스트로 선택합니다. 이것은 <code>0 번 라인으로 이동한 다음, 순방향(</code>+<code>)으로 &quot;Emacs&quot; 패턴을 검색합니다</code> 로 읽으면 됩니다.</p>
<p>또한, 순방향 검색 문자인 <code>+</code> 는 선택 사항이므로, <code>0/Emacs/</code> 형태로 사용해도 동일하게 작동합니다. 이와 비슷하게</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>$-/Emacs/
</span></span></code></pre></div><p>이 검색 명령은 파일 마지막(<code>$</code>)으로 이동한 후, 역방향(<code>-</code>)으로 &ldquo;Emcas&rdquo; 패턴 문자열을 처음으로 발견한 곳을 현재텍스트로 설정합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0/Emacs/,$-/Emacs/
</span></span></code></pre></div><p>이 검색 명령은 파일 처음으로 이동한 후, 순방향 검색으로 첫 번째 검색 일치한 &ldquo;Emacs&rdquo; 부터 다시 파일 마지막으로 이동한 후, 역방향 검색으로 첫 번째로 검색 일치한 &ldquo;Emacs&rdquo; 까지를 범위로 선택합니다.</p>
<p>좀 더 흥미로운 예제는</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>/Emacs/+/Emacs/
</span></span></code></pre></div><p>(처음 부분에 암시적으로 <code>.+</code> 가 있음) 점 (현재텍스트) 부터 순방향 검색으로 첫 번째 &ldquo;Emacs&rdquo; 를 찾은 다음, 그 다음 두 번째 &ldquo;Emacs&rdquo; 를 선택합니다.</p>
<p>또한, 라인 번호는 현재텍스트에 상대적일 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>-2
</span></span></code></pre></div><p>이 명령은 현재텍스트의 이전 두 라인을 선택하는 명령이고, 다음과 같은 것은</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>+5
</span></span></code></pre></div><p>현재텍스트의 다음 다섯 라인을 선택합니다. (여기서 사용한 더하기 문자는 <strong>필수</strong> 입니다.)</p>
<p>주소 (또는 점) 는 한 라인 이상도 선택할 수 있으므로, <code>이전</code> 과 <code>다음</code> 에 대한 정확한 정의가 필요합니다. <code>이전</code> 은 현재텍스트 시작 부분 이전을 의미하고, <code>다음</code> 은 현재텍스트 끝 부분 이후를 의미합니다.</p>
<p>예를 들어, 파일에 &ldquo;AAAA&rdquo; 문자열이 포함되어 있고 현재텍스트는 두 번째 A 문자에 설정되어 있다고 가정한다면, <code>-/A/</code> 는 현재텍스트를 첫 번째 A 문자로 설정하고, <code>+/A/</code> 는 현재텍스트를 다음 A 문자로 설정합니다.
아주 이상한 상황을 제외하고 (예: 파일내의 유일한 항목이 이미 현재텍스트일 경우) 현재텍스트를 기준으로 분리되어 처리됩니다.</p>
<p>라인 길이에 관계없이 점 문자로 시작하는 troff ‑ms 매크로 패키지의 단락 부분만 선택하려면 다음과 같이 사용합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>-/.PP/,/.PP/-1
</span></span></code></pre></div><p>여기서 단락을 시작하는 .PP 매크로는 선택되지만, 단락을 끝내는 .PP 매크로는 제외됩니다.(-1)</p>
<p>상대 주소로 입력할 때 기본값은 <code>1</code> 이므로 위의 명령은 좀 더 간단하게 축약해 작성할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>-/.PP/,/.PP/-
</span></span></code></pre></div><p>주소 <code>+1‑1</code> 또는 이에 상응하는 단축된 표현인 <code>+‑</code> 는 과연 무엇을 의미할까요? 이것은 아무것도 처리하지 않는 것처럼 보이지만, 현재텍스트는 반드시 완전한 텍스트 라인일 필요는 없습니다.
즉, <code>+1</code> 은 현재텍스트 끝의 다음 라인을 의미하고, <code>‑1</code> 은 현재텍스트 시작의 이전 라인을 의미합니다. 따라서, <code>+1‑1</code> 은 현재텍스트 뒷 라인과 앞 라인 즉, <code>현재텍스트를 포함한 완전한 라인을 선택</code> 합니다.</p>
<p>이런 구문을 사용해 &ldquo;Emacs&rdquo; 를 포함한 완전한 라인을 선택할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0/Emacs/+-p
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs and to try to show
</span></span></code></pre></div><p><code>+‑</code> 구문은 sam 편집기만의 <strong>관용구</strong> 입니다.</p>
<p><a href="#top">:arrow_up:</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="loops">Loops</h1>
<p>위에서 &ldquo;Emacs&rdquo; 의 한 항목을 &ldquo;Emacs\360&rdquo; 으로 임의로 변경했지만, 만약 Emacs 편집기 이름이 실제로 변경될 경우, 단일 명령만으로 모든 Emacs 편집기 이름 인스턴스를 변경하는 것은 유용할 것입니다.</p>
<p>sam 은 이런 반복 작업을 처리하기 위해 <code>x</code> (<em>extract</em>) 명령을 제공합니다. 명령 구문은 <code>x/pattern/command</code> 입니다.</p>
<p><code>x</code> 명령은 &ldquo;pattern&rdquo; 이 검색된다면 현재텍스트로 설정하고 &ldquo;command&rdquo; 명령을 실행합니다. 예를 들어, &ldquo;Emacs&rdquo; 를 &ldquo;vi&rdquo; 로 변경하려면</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0,$x/Emacs/c/vi/
</span></span><span style="display:flex;"><span>0,$p
</span></span><span style="display:flex;"><span>This manual is organized in a rather haphazard manner. The first
</span></span><span style="display:flex;"><span>several sections were written hastily in an attempt to provide a
</span></span><span style="display:flex;"><span>general introduction to the commands in vi and to try to show
</span></span><span style="display:flex;"><span>the method in the madness that is the vi command structure.
</span></span></code></pre></div><p>이 명령은 전체 텍스트 (<code>0,$</code> — 전체 파일) 범위로 검색 패턴 (&ldquo;Emacs&rdquo;) 을 모두 검색한 다음, 현재텍스트로 설정하고 명령 (<code>c/vi/</code>) 을 실행해 텍스트를 변경합니다.</p>
<p>이 예제는 &ldquo;파일내의 모든 Emacs 항목을 찾아 현재텍스트로 설정한 후, vi 로 대체하는 <code>c/vi/</code> 명령을 실행합니다.&rdquo; 라고 읽을 수 있습니다.</p>
<blockquote>
<p>[!NOTE]
[이 명령은 ed 편집기의 <code>g</code> (<em>global</em>) 명령과 다소 유사합니다. 주된 차이점은 다음에 자세히 설명하겠지만 항상 그렇듯이 기본 처리 단위는 전체 파일이 아니라 현재텍스트 (점) 입니다.]</p></blockquote>
<p>단일 <code>u</code> (<em>undo</em>) 명령은 <code>x</code> 명령으로 변경한 결과에 관계없이 <code>x</code> 명령을 실행 취소하는 데 충분합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>u
</span></span><span style="display:flex;"><span>0,$p
</span></span><span style="display:flex;"><span>This manual is organized in a rather haphazard manner. The first
</span></span><span style="display:flex;"><span>several sections were written hastily in an attempt to provide a
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs and to try to show
</span></span><span style="display:flex;"><span>the method in the madness that is the Emacs command structure.
</span></span></code></pre></div><p>물론, <code>c</code> 명령만 <code>x</code> 명령에서 실행할 수 있는 유일한 명령은 아닙니다. 다음과 같이 <code>a</code> 명령을 사용해 &ldquo;Emacs&rdquo; 에 TM (<em>Trade Mark</em>) 표시를 추가할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0,$x/Emacs/a/{TM}/
</span></span><span style="display:flex;"><span>/Emacs/+-p
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs{TM} and to try to show
</span></span></code></pre></div><blockquote>
<p>[!NOTE]
[ed 의 <code>g/Emacs/s//&amp;{TM}/p</code> 같이 변경 사항을 단계적으로 모두 출력하면서 처리할 방법은 없습니다. 변경 섹션 참조 ]</p></blockquote>
<p><code>x</code> 명령과 <code>p</code> 명령을 함께 사용하는 경우도 유용할 수 있겠지만 출력 결과는 주의하시기 바랍니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0,$x/Emacs/p
</span></span><span style="display:flex;"><span>EmacsEmacs
</span></span></code></pre></div><p><code>x</code> 명령은 슬래시 문자안의 검색 패턴 텍스트를 현재텍스트로 설정하기 때문에, 현재텍스트만 <code>p</code> 명령으로 출력한다는 것은 그다지 유용하지 않을 수 있습니다. 그러나, <code>x</code> 명령은 관용구를 포함할 수 있습니다.</p>
<p>예를 들어, &ldquo;Emacs&rdquo; 를 포함한 모든 라인을 출력하려면 <code>+‑</code> 관용구를 사용합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0,$x/Emacs/+-p
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs{TM} and to try to show
</span></span><span style="display:flex;"><span>the method in the madness that is the Emacs{TM} command structure.
</span></span></code></pre></div><p>마지막으로, <code>x</code> 명령으로 이전에 변경했던 내용을 이전 상태로 복원합니다. 주소 부분에 쉼표 문자만 사용할 경우, 주소 왼쪽의 기본값은 <code>0</code> 이고, 오른쪽의 기본값은 <code>$</code> 이므로, <strong>쉼표 주소는 전체 파일을 의미</strong> 합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/Emacs/ /{TM}/d
</span></span><span style="display:flex;"><span>,p
</span></span><span style="display:flex;"><span>This manual is organized in a rather haphazard manner. The first
</span></span><span style="display:flex;"><span>several sections were written hastily in an attempt to provide a
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs and to try to show
</span></span><span style="display:flex;"><span>the method in the madness that is the Emacs command structure.
</span></span></code></pre></div><p>위의 <code>x</code> 명령이 어떻게 처리하는지 잠시 생각해보시기 바랍니다. 파일 전체(<code>,</code>) 범위에서 &ldquo;Emacs&rdquo; 가 나타날 때마다 뒤따른 &ldquo;{TM}&rdquo; 을 찾은 후, 삭제(<code>d</code>)합니다.</p>
<p>sam 은 &ldquo;text&rdquo; 같은 텍스트 패턴을 주소 및 <code>x</code> 명령에 사용할 수 있도록 허용하며, 사실 이것은 단순한 텍스트가 아니라 <code>정규표현식</code> 입니다.</p>
<p>Unix 에는 정규표현식에 대한 몇 가지 해석 방법이 있습니다. (기본 정규표현식, 확장 정규표현식, 펄 정규표현식 등) sam 에서 사용하는 정규표현식은 하위 표현식의 그룹화를 위한 괄호 <code>()</code> 문자,
문자열을 병렬로 일치시키기 위한 &ldquo;or&rdquo; 연산자 <code>|</code> 를 포함하는 <code>regexp(6)</code> 을 사용합니다.</p>
<p>또한, sam 은 문자 시퀀스 <code>\n</code> 을 <strong>개행 문자로 인식</strong> 합니다. <code>a</code> 및 <code>c</code> 명령으로 입력한 텍스트는 여전히 일반 텍스트지만, 패턴 텍스트내에 입력한 <code>\n</code> 문자는 <code>개행 문자로 해석</code> 합니다.</p>
<blockquote>
<p>[!NOTE]
[ed 는 대체 명령에서 개행 문자를 표현하기 위해 백슬래시 <code>\</code> 문자를 사용합니다.]</p></blockquote>
<p>다음은 개행 문자에 대한 몇 가지 처리 예제입니다. 예를 들어, 문서내의 라인 간격을 두 배로 늘리고 싶다고 가정합니다. 즉, 모든 개행 문자를 하나 더 추가해서 두 개의 개행 문자로 바꿉니다. 다음과 같은 명령으로 작업을 수행합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/\n/ a/\n/
</span></span><span style="display:flex;"><span>,x/\n/ c/\n\n/
</span></span><span style="display:flex;"><span>,x/$/ a/\n/
</span></span><span style="display:flex;"><span>,x/ˆ/ i/\n/
</span></span></code></pre></div><p>마지막 예제는 처리 방식이 약간 다릅니다. 각 라인 앞에 (<code>^</code>) 개행 문자를 추가하기 때문입니다. 다른 예제는 모두 라인 뒤에 (<code>$</code>) 개행 문자를 추가합니다. 또한, 처음 두 예제는 개행 문자를 직접 조작해서 처리합니다.
마지막 두 예제는 정규표현식의 특수 문자를 사용해서 처리합니다. <code>$</code> 문자는 라인 끝에 있는 문자열의 끝을 의미하고, <code>^</code> 문자는 문자열의 시작을 의미하는 정규표현식 특수 문자입니다.</p>
<p>상기의 처리 방법에는 한 가지 단점이 존재합니다. 만약, 파일에 이미 두 개의 빈 라인이 포함된 경우 (즉, 두 개의 연속된 개행 문자), 빈 라인을 훨씬 더 크게 만들어 버립니다.
(즉, 4개의 연속된 개행 문자) 좀 더 나은 처리 방법은 모든 개행 문자를 최소한 하나로만 한정하는 정규표현식의 특수 문자(<code>+</code>)를 사용하는 것입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/\n+/ a/\n/
</span></span></code></pre></div><p>정규표현식의 특수 문자 <code>+</code> 는 <strong>하나 이상</strong> 을 의미합니다. 즉, <code>\n+</code> 는 기본 정규표현식의 <code>\n\n*</code> 과 동일합니다. 따라서, 이 예제에선 한 개의 개행 문자로 구성된 라인만 검색한 후, 끝 부분에 개행 문자를 추가합니다.</p>
<p>좀 더 일반적인 예제는 탭 문자를 추가해 텍스트 블록을 들여쓰기 처리하는 것입니다. 다음 예제는 모두 동일하게 작동하지만, 첫 번째 예제가 사용하기에 가장 깔끔합니다. (슬래시 문자안의 <code>□</code> 문자는 탭 문자임)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/ˆ/ a/□/
</span></span><span style="display:flex;"><span>,x/ˆ/ c/□/
</span></span><span style="display:flex;"><span>,x/.*\n/ i/□/
</span></span></code></pre></div><p>마지막 예제는 라인 전체를 일치시키기 위한 정규표현식 패턴인 (실제로는 관용구) <code>.*\n</code> 을 사용합니다. <code>.*</code> 는 개행 문자를 제외한 모든 문자를 가능한 한 가장 긴 문자열과 일치합니다.</p>
<p>또한, 들여쓰기로 사용한 탭 문자를 제거하는 것도 쉽게 처리할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/ˆ□/d
</span></span></code></pre></div><p>이 예제는 주소 (전체 파일) 를 직접 지정해서 처리했지만, 실제 이와 같은 편집 작업은 마우스로 텍스트를 직접 선택한 후, 현재텍스트로 설정해서 별도의 주소 지정없이 처리할 가능성이 더 큽니다.</p>
<p><a href="#top">:arrow_up:</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="conditionals">Conditionals</h1>
<p><code>x</code> 명령은 반복 처리 구문입니다. 정규표현식으로 정의된 각각의 일치 항목에 대해 항목을 추출 (현재텍스트로 설정) 한 후, 함께 지정한 명령을 실행합니다.</p>
<p>또한, sam 에는 조건부 <code>g</code> (<em>guard</em>) 명령도 있습니다. <code>g/pattern/command</code> 명령은 현재텍스트 (<em>dot</em>) 값을 변경하지 않고, 현재텍스트에 일치하는 패턴이 포함된 경우에만 해당 명령을 실행합니다.
<code>v</code> 명령은 현재텍스트에 일치하는 패턴이 포함되지 않은 경우에만 해당 명령을 실행합니다. (<code>g</code> 와 <code>v</code> 명령은 역사적인 것이며 니모닉에 별다른 의미는 없습니다. 단지 <code>g</code> 를 &ldquo;보호(<em>guard</em>)&rdquo; 라고 생각할 수 있습니다.)</p>
<blockquote>
<p>[!CAUTION]
[ed 사용자는 위의 명령을 매우 주의깊게 읽어야 합니다. sam 의 <code>g</code> 명령은 ed 의 <code>g</code> 명령과 근본적으로 처리 개념이 완전히 다릅니다.]</p></blockquote>
<p>다음의 예제는 <code>x</code> 명령과 <code>g</code> 명령의 차이점에 대한 예제입니다 .</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/Emacs/c/vi/
</span></span></code></pre></div><p>이 명령은 파일내에 &ldquo;Emacs&rdquo; 라는 단어가 나올 때마다 &ldquo;vi&rdquo; 라는 단어로 변경하지만</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,g/Emacs/c/vi/
</span></span></code></pre></div><p>이 명령은 파일내에 &ldquo;Emacs&rdquo; 라는 단어가 포함되어 있다면, <strong>파일 전체를 &ldquo;vi&rdquo; 로 변경합니다!!</strong></p>
<p>이 두 명령 중 어느 것도 단독으로 사용할 땐 특별히 흥미롭지 않지만 <code>x</code> 명령과 결합해 사용할 땐 매우 유용할 수 있습니다.</p>
<p><a href="#top">:arrow_up:</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="composition">Composition</h1>
<p><code>x</code> 명령에 대해 한 가지 기억해 둘 것은 어떤 선택 (점의 값) 이 주어지면 선택내에서 다시 하위 선택(점의 값)을 반복할 수 있다는 것입니다. 즉, 텍스트 조각을 가져온 후, 거기서 다시 더 작은 조각으로 자를 수 있습니다.
잘려진 텍스트는 이전 <code>x</code> 명령에 의해 잘린 조각이거나, <code>g</code> 명령에 의해 조건부로 선택된 텍스트 조각일 수 있습니다.</p>
<p>이처럼 sam 의 가장 흥미로운 특성 중 하나는 특정 작업을 수행하기 위해 일련의 명령을 연계해 조합할 수 있는 처리 능력입니다.</p>
<blockquote>
<p>[!TIP]
시스템 쉘의 파이프 라인과의 명백한 비교는 부분적으로만 유효합니다. 개별 sam 명령은 모두 동일한 텍스트에만 작용하기 때문입니다. 다른 것은 단지 텍스트가 슬라이스 되는 처리 방식뿐입니다.</p></blockquote>
<p>간단한 예제로 파일내의 모든 &ldquo;Emacs&rdquo; 를 &ldquo;emacs&rdquo; 로 변경하는 것입니다. 확실히 다음과 같은 명령은</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/Emacs/ c/emacs/
</span></span></code></pre></div><p>이 명령은 정상적으로 작동하지만, <code>x</code> 명령을 사용할 때 &ldquo;Emacs&rdquo; 를 입력한 것을 다음과 같이 재사용할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/Emacs/ x/E/ c/e/
</span></span></code></pre></div><blockquote>
<p>[!TIP]
공백 문자를 사용해 명령을 보다 읽기쉽게 만들 수 있습니다.</p></blockquote>
<p>이 명령이 처리하는 일은 &ldquo;Emacs&rdquo; (<code>,x/Emacs/</code>) 의 모든 항목을 찾은 다음, 해당 텍스트를 현재텍스트로 설정하고 그 문자열내에서 다시 &ldquo;E&rdquo; 문자을 찾는 (<code>x/E/</code>) 것입니다.
&ldquo;E&rdquo; 문자를 찾은 다음, 현재텍스트를 해당 문자로 설정한 후, <code>c/e/</code> 명령을 실행해 소문자로 변경합니다.</p>
<p>따라서, 명령에 사용한 주소 (쉼표로 지정된 전체 파일) 는 명령 가장 왼쪽 부분에 한 번만 제공합니다. 나머지는 왼쪽 명령의 선택된 문자열을 기준으로 실행해 현재텍스트로 설정했습니다.</p>
<p>또 다른 간단한 예제로 위에서 이미 해결했던 문제를 다시 한 번 처리합니다. &ldquo;Emacs&rdquo; 라는 단어가 포함된 모든 라인을 출력합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/.*\n/ g/Emacs/p
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs and to try to show
</span></span><span style="display:flex;"><span>the method in the madness that is the Emacs command structure.
</span></span></code></pre></div><p>이 명령은 파일을 먼저 라인 (<code>,x/.*\n/</code>) 단위로 나누고, &ldquo;Emacs&rdquo; (<code>g/Emacs/</code>) 를 포함한 각각의 라인을 현재텍스트로 설정한 후, <code>p</code> 명령을 실행해 (&ldquo;Emacs&rdquo; 이 포함된) 해당 라인을 출력합니다.</p>
<p>입력 시간을 조금이라도 절약하기 위해 <code>라인 처리 단위</code> 를 의미하는 <code>.*\n</code> 구문은 <code>x</code> 명령에서 자주 사용하는 관용구이므로, <code>x</code> 명령 바로 뒤에 공백 문자만 있다면 <code>.*\n</code> 패턴이라 가정합니다.</p>
<p>따라서, 위의 예제는 다음과 같이 좀 더 간결하게 작성할 수 있습니다. (<code>□</code> 는 공백 문자를 의미합니다.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x□g/Emacs/p
</span></span></code></pre></div><p>지금까지 사용했던 처리 방법은 다음과 같습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/Emacs/+-p
</span></span></code></pre></div><p>이것은 파일내 &ldquo;Emacs&rdquo; 의 각 일치 항목으로 현재텍스트를 설정한 후, 관용구 <code>+‑p</code> 명령을 실행합니다.</p>
<blockquote>
<p>[!TIP]
관용구 <code>+‑p</code> 는 현재텍스트가 포함된 라인 전체를 출력한다는 것을 기억하시기 바랍니다.</p></blockquote>
<p>두 명령은 일반적으로 동일한 결과물을 생성합니다. (<code>+‑p</code> 형식은 한 라인에 &ldquo;Emacs&rdquo; 를 두 번 포함한 라인이 있을 경우, 한 라인을 두 번 출력합니다.) 과연 어떤게 더 좋을까요?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/Emacs/+‑p
</span></span></code></pre></div><p>형식은 입력하기 쉬우며, 파일이 크고 문자열이 거의 검색되지 않을 경우라면 훨씬 더 빠르게 처리되지만 실제론 매우 특수한 경우입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/.*\n/ g/Emacs/p 
</span></span></code></pre></div><p>형식은 비록 입력 속도는 조금 더 걸리겠지만 — 먼저 각 라인을 개별적으로 분리한 다음 처리합니다 — 개념적으론 훨씬 더 깔끔하고 좀 더 쉽게 일반화할 수 있습니다.</p>
<p>예를 들어, &ldquo;Emacs&rdquo; 매뉴얼의 다음과 같은 부분을 처리해야 한다고 가정합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>command name=&#34;append-to-file&#34;, key=&#34;[unbound]&#34;
</span></span><span style="display:flex;"><span>Takes the contents of the current buffer and appends it to the
</span></span><span style="display:flex;"><span>named file. If the file doesn’t exist, it will be created.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>command name=&#34;apropos&#34;, key=&#34;ESC-?&#34;
</span></span><span style="display:flex;"><span>Prompts for a keyword and then prints a list of those commands
</span></span><span style="display:flex;"><span>whose short description contains that keyword. For example,
</span></span><span style="display:flex;"><span>if you forget which commands deal with windows, just type
</span></span><span style="display:flex;"><span>&#34;@b[ESC-?]@t[window]@b[ESC]&#34;.
</span></span></code></pre></div><p>이 텍스트는 빈 라인이 아닌 그룹으로 구성되어 있으며 각 그룹내의 텍스트 또한 간단한 형식이 있습니다. 가령 &ldquo;apropos&rdquo; 명령에 대한 설명을 찾고싶다고 가정합니다.</p>
<p>우선, 파일을 개별적인 설명 그룹 단위로 나눈 다음, &ldquo;apropos&rdquo; 의 설명 부분만 찾아 출력하는 것입니다. 따라서, 해결책은 매우 간단합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/(.+\n)+/ g/command name=&#34;apropos&#34;/p
</span></span><span style="display:flex;"><span>command name=&#34;apropos&#34;, key=&#34;ESC-?&#34;
</span></span><span style="display:flex;"><span>Prompts for a keyword and then prints a list of those commands
</span></span><span style="display:flex;"><span>whose short description contains that keyword. For example,
</span></span><span style="display:flex;"><span>if you forget which commands deal with windows, just type
</span></span><span style="display:flex;"><span>&#34;@b[ESC-?]@t[window]@b[ESC]&#34;.
</span></span></code></pre></div><p>정규표현식 <code>(.+\n)+</code> 는 최소한 하나 이상의 문자가 포함되고 개행 문자가 하나 이상 포함된 라인 즉, 빈라인이 아닌 것과 일치하므로, <code>x/(.+\n)+/</code> 는 빈 라인을 제외한 각각의 설명 부분만 추출합니다.
그런 다음, <code>g/command name=&quot;apropos&quot;/</code> 명령은 &ldquo;apropos&rdquo; 에 대한 설명을 검색한 후, <code>p</code> 명령으로 출력합니다.</p>
<p>또 다른 예로는 C프로그램에서 변수 &ldquo;n&rdquo; 을 &ldquo;num&rdquo; 으로 모두 변경해야 한다고 가정합니다. 다음은 첫 번째 시도입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/n/ c/num/
</span></span></code></pre></div><p>그러나, 이 처리 방법엔 분명 심각한 결함이 포함되어 있습니다. 변수 &ldquo;n&rdquo; 뿐만아니라 파일내에 포함된 모든 &ldquo;n&rdquo; 문자를 변경할 것입니다.</p>
<p>좀 더 나은 솔루션은 <code>x</code> 명령을 사용해, 일단 변수들만 추출한 다음, <code>g</code> 명령을 사용해서 다시 &ldquo;n&rdquo; 문자를 찾는 방법입니다. 즉, 다음과 같습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/[a-zA-Z_][a-zA-Z_0-9]*/ g/n/ v/../ c/num/
</span></span></code></pre></div><p>보기엔 비록 끔찍해 보일 수 있겠지만, 왼쪽에서 오른쪽으로 천천히 읽어나간다면 이해하기는 쉽습니다.</p>
<p>C언어의 변수는 0개 이상의 영숫자 또는 밑줄이 뒤따르는 영문자 또는 밑줄 문자입니다. 즉, 정규표현식으론 <code>[a‑zA‑Z_][a‑zA‑Z_0‑9]*</code> 와 일치합니다. <code>g</code> 명령으로 &ldquo;n&rdquo; 을 포함한 변수만 선택하고 <code>v</code> 명령은 일종의 트릭입니다.
하나 이상의 문자를 포함한 변수를 거부(제외)합니다. 따라서, <code>c/num/</code> 명령은 단일 문자로 구성된 &ldquo;n&rdquo; 변수에만 적용됩니다.</p>
<p>하지만, 아직까지 여전히 문제점이 남아있습니다. 문자 상수인 개행 문자 <code>\n</code> 에 포함된 &ldquo;n&rdquo; 문자는 변경하고 싶지 않습니다.</p>
<p><code>x</code> 명령을 보완하는 <code>y</code> 명령이 있습니다. 지금 가장 필요한 명령입니다. <code>y/pattern/command</code> 명령은 일치되지 않은  텍스트 조각에 대해서만 명령을 실행합니다. 즉,  <code>x</code> 명령이 선택한다면 <code>y</code> 명령은 거부합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,y/\\n/ x/[a-zA-Z_][a-zA-Z_0-9]*/ g/n/ v/../ c/num/
</span></span></code></pre></div><p><code>y/\\n/</code> (개행 문자를 일반 리터럴 문자로 만들기 위해 백슬래시를 두 번 사용함) 은 처리 대상에 두 문자 시퀀스인 <code>\n</code> 을 제외하므로, 이후 명령에서 이 부분을 건드리지 않습니다.</p>
<p>사실, 처리할 일이 하나 더 있습니다. 예를 들어, 소스 코드내의 주석문도 처리에서 제외하기 위해, 또다른 <code>y</code> 명령을 추가로 사용할 수 있습니다. 더 이상 자세히 설명하진 않겠지만, sam 의 루핑 및 조건부 명령으로
흥미로운 작업을 수행할 수 있도록 구성할 수 있는 여러 가지 처리 방법에 대한 자신만의 아이디어가 있어야 합니다.</p>
<p><a href="#top">:arrow_up:</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="grouping">Grouping</h1>
<p>명령을 조합해 처리할 수 있는 또 다른 방법이 있습니다. 중괄호 <code>{...}</code> 문자로 명령들을 한데 묶어 명령을 병렬로 실행할 수 있습니다.</p>
<p>다음 예제는 파일내의 &ldquo;Emacs&rdquo; 일치 항목만 상세히 출력하기 위해, <code>p</code> 명령과 함께 현재텍스트에 대한 라인 번호 및 문자 번호까지 출력하는 <code>=</code> 명령을 사용합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,p
</span></span><span style="display:flex;"><span>This manual is organized in a rather haphazard manner. The first
</span></span><span style="display:flex;"><span>several sections were written hastily in an attempt to provide a
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs and to try to show
</span></span><span style="display:flex;"><span>the method in the madness that is the Emacs command structure.
</span></span><span style="display:flex;"><span>,x/Emacs/{
</span></span><span style="display:flex;"><span>=
</span></span><span style="display:flex;"><span>+-p
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>3; #171,#176
</span></span><span style="display:flex;"><span>general introduction to the commands in Emacs and to try to show
</span></span><span style="display:flex;"><span>4; #234,#239
</span></span><span style="display:flex;"><span>the method in the madness that is the Emacs command structure.
</span></span></code></pre></div><blockquote>
<p>[!TIP]
세미콜론 앞의 숫자는 라인 번호이며, # 문자로 시작하는 숫자는 문자 번호입니다.</p></blockquote>
<p>좀 더 흥미로운 예제로는 모든 &ldquo;Emacs&rdquo; 항목을 &ldquo;vi&rdquo; 로 변경하고, 그 반대로도 변경하는 것입니다. 이 작업은 다음과 같이 실행해 처리합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/Emacs|vi/ {
</span></span><span style="display:flex;"><span>  g/Emacs/ c/vi/
</span></span><span style="display:flex;"><span>  g/vi/ c/Emacs/
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>또는, 다음과 같이</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/[a-zA-Z]+/ {
</span></span><span style="display:flex;"><span>  g/Emacs/ v/....../ c/vi/
</span></span><span style="display:flex;"><span>  g/vi/ v/.../ c/Emacs/
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>단어내에 포함된 문자열은 변경하지 않도록 처리합니다.</p>
<p><a href="#top">:arrow_up:</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="multiple-changes">Multiple Changes</h1>
<p>위의 예제에서 &ldquo;Emacs&rdquo; 가 &ldquo;vi&rdquo; 로 변경된 후, 두 번째 명령에서 다시 재처리하지 않는 이유에 대해 궁금할 것입니다.</p>
<p>그 이유는 <code>그룹 명령은 병렬로 동시에 실행</code> 되기 때문입니다. 최상위 sam 명령에서 파일에 대한 모든 변경 사항은 해당 명령으로 변경되기 이전 파일 상태를 기반으로 실행합니다. 모든 변경 사항이 결정되면 동시에 모두 (병렬) 적용합니다.</p>
<p>즉, 설명한 것과 같이 그룹 명령내의 명령은 변경 사항이 적용되기 이전의 파일 상태를 확인합니다. 이런 평가 방법은 어떤 것은 처리를 좀 더 쉽게 만들고 (예: &ldquo;Emacs&rdquo; 와 &ldquo;vi&rdquo; 의 교환) 어떤 것은 처리하기 더 어렵게 만듭니다.</p>
<p>예를 들어, <code>p</code> 명령이 실행될 때는 변경 사항이 아직 발생하지 않았기 때문에 변경된 사항을 출력하기 위해 <code>p</code> 명령을 실행한다는 것 자체가 불가능할 것입니다.</p>
<p>이로 인한 간접적인 파급 효과는 변경 사항이 파일을 통해 정방향으로만 발생해야 하며 서로 겹치지 않아야 한다는 것입니다.</p>
<p><a href="#top">:arrow_up:</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="unix">Unix</h1>
<p>sam 에는 Unix 프로세스와 연결하기 위한 몇 가지 명령이 포함되어 있습니다. 가장 간단한 것은 Unix 프로그램을 실행하는 <code>!</code> (<em>shell escape</em>)  명령입니다. 프로그램의 입력과 출력을 연결할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>!date
</span></span><span style="display:flex;"><span>Wed May 28 23:25:21 EDT 1986
</span></span><span style="display:flex;"><span>!
</span></span></code></pre></div><blockquote>
<p>[!TIP]
다운로드 모드로 실행할 때, 입력은 <code>/dev/null</code> 에 연결되고 출력은 처음 몇 라인까지만 출력됩니다. 나머지 오버플로된 내용은 <code>$HOME/sam.err</code> 파일에 저장됩니다.</p></blockquote>
<p>마지막의 <code>!</code> 문자는 Unix 프로그램이 정상적으로 실행을 완료할 때 표시하는 프롬프트 문자입니다.</p>
<p>흥미로운 것은 현재텍스트를 Unix 프로그램에 대한 표준 입력으로 제공하는 <code>&gt;</code> 명령입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1,2 &gt;wc
</span></span><span style="display:flex;"><span>2 22 131
</span></span><span style="display:flex;"><span>!
</span></span></code></pre></div><p><code>&gt;</code> 명령의 보완 명령은 당연히 <code>&lt;</code> 명령입니다. 현재텍스트를 Unix 프로그램의 표준 출력 결과로 입력합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1 &lt;date
</span></span><span style="display:flex;"><span>!
</span></span><span style="display:flex;"><span>1p
</span></span><span style="display:flex;"><span>Wed May 28 23:26:44 EDT 1986
</span></span></code></pre></div><p>다음으로 <code>|</code> (<em>pipe</em>) 명령은 <code>&lt;</code> 명령과 <code>&gt;</code> 명령의 조합으로 현재텍스트를 Unix 프로그램에 대한 표준 입력으로 제공하고, Unix 프로그램의 표준 출력이 수집된 후, 다시 원본 현재텍스트를 대체하는 용도로 사용합니다.</p>
<p>예를 들어,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,| sort
</span></span></code></pre></div><p>파일 전체(<code>,</code>) 를 <code>sort(1)</code> 프로그램의 입력으로 전달해 사전순으로 정렬한 후, 정렬된 결과를 현재텍스트로 대체합니다.</p>
<p>이들 <code>&lt;</code> , <code>&gt;</code> 및 <code>|</code> 명령들은 Unix 쉘의 연산자가 아니라 sam 전용 명령어입니다.</p>
<p>다음 예제는 <code>tr(1)</code> 프로그램을 사용해서 &ldquo;Emacs&rdquo; 의 모든 문자를 대문자로 변환합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/Emacs/ | tr a-z A-Z
</span></span></code></pre></div><p><code>tr</code> 프로그램은 &ldquo;Emacs&rdquo; 문자열이 발생할 때마다 매번 실행됩니다. 물론, 이것은 간단한 <code>c</code> 명령으로 더 효율적으로 처리할 수 있겠지만, 처리하기 좀 더 까다로운 상황도 있습니다.</p>
<p>예를 들어, 다음 예제는 입력으로 Unix 메일 주소가 주어진다면 모든 메일 제목 헤더를 <code>fortune</code> (운세 프로그램) 의 출력 결과로 변환합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/ˆSubject:.*\n/ x/[ˆ:]*\n/ &lt; /usr/games/fortune
</span></span></code></pre></div><blockquote>
<p>[!TIP]
정규표현식 <code>[^:]</code> 은 콜론 &ldquo;:&rdquo; 문자를 제외한 모든 문자를 나타냅니다.</p></blockquote>
<p><code>/usr/games/fortune</code> 프로그램은 각 제목 라인에 대해 한 번씩 매번 실행되므로 각각의 제목 라인은 새로운 운세 (fortune) 로 변경됩니다.</p>
<p><a href="#top">:arrow_up:</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="a-few-other-text-commands">A few other text commands</h1>
<p>보다 완벽을 기하기 위해 텍스트를 조작하는 세 가지 다른 명령도 설명해야 합니다.</p>
<p><code>m</code> (<em>move</em>) 명령은 명령 뒤의 (필수) 주소로 명령 앞에 지정한 텍스트를 이동합니다. 따라서,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>/Emacs/+- m 0
</span></span></code></pre></div><p>&ldquo;Emacs&rdquo; 를 포함한 라인(<code>+-</code>)을 파일의 시작 부분(0)으로 이동(<code>m</code>)합니다.</p>
<p>마찬가지로, <code>t</code> (<em>transfer</em>, 또 다른 역사적 명령 문자)는 텍스트를 복사합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>/Emacs/+- t 0
</span></span></code></pre></div><p>위의 명령은 파일 시작 부분으로 &ldquo;Emacs&rdquo; 를 포함한 라인에 대한 복사본을 만듭니다.</p>
<p>세 번째로 설명할 명령은 좀 더 흥미롭습니다. 바로 대체 <code>s</code> (<em>substitute</em>} 명령입니다. 명령 구문은 <code>s/pattern/replacement/</code> 입니다.</p>
<p>현재텍스트내에서 패턴의 (pattern) 첫 번째 일치 항목을 찾은 후, 대체 (replacement) 텍스트로 대체하고 현재텍스트 (점) 는 대체 텍스트로 설정합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1p
</span></span><span style="display:flex;"><span>This manual is organized in a rather haphazard manner. The first
</span></span><span style="display:flex;"><span>s/haphazard/thoughtless/
</span></span><span style="display:flex;"><span>p
</span></span><span style="display:flex;"><span>This manual is organized in a rather thoughtless manner. The first
</span></span><span style="display:flex;"><span>Occurrences of the character &amp; in the replacement text stand for the text matching the pattern.
</span></span><span style="display:flex;"><span>s/T/&#34;&amp;&amp;&amp;&amp;&#34;/
</span></span><span style="display:flex;"><span>p
</span></span><span style="display:flex;"><span>&#34;TTTT&#34;his manual is organized in a rather thoughtless manner. The first
</span></span></code></pre></div><p>대체 텍스트에서 사용한 <code>&amp;</code> 문자는 검색 패턴 문자열 자체를 나타냅니다.</p>
<p>대체 명령은 두 가지 변형된 사용 형식이 있습니다. 첫 번째는 대체할 패턴의 발생 위치를 지정하기 위해, <code>s</code> 명령 뒤에 숫자를 지정할 수 있다는 것입니다. 기본값은 첫 번째 패턴 발생 위치입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>s2/is/was/
</span></span><span style="display:flex;"><span>p
</span></span><span style="display:flex;"><span>&#34;TTTT&#34;his manual was organized in a rather thoughtless manner. The first
</span></span></code></pre></div><p>두 번째는 접미사 <code>g</code> (<em>global</em>) 명령은 첫 번째 일치 항목 뿐만아니라 모든 일치 항목을 대체한다는 것입니다. .</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>s/[a-zA-Z]/x/g
</span></span><span style="display:flex;"><span>p
</span></span><span style="display:flex;"><span>&#34;xxxx&#34;xxx xxxxxx xxx xxxxxxxxx xx x xxxxxx xxxxxxxxxxx xxxxxxx xxx xxxxx
</span></span></code></pre></div><p>이 모든 예제의 현재텍스트는 전체 라인으로 설정됩니다</p>
<p>[ed 의 대체 명령은 라인내에서 변경 작업을 처리하는 유일한 방법이기 때문에 매우 중요합니다. 하지만, 라인 단위 처리 개념이 훨씬 덜 중요한 sam 에선 그 중요도가 많이 떯어집니다.]</p>
<p>예를 들어, ed 대체 명령 관용구는 sam 의 기본 명령으로 잘 처리할 수 있습니다. 다음과 같은 명령을 가정합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>s/good/bad/
</span></span><span style="display:flex;"><span>s/good//
</span></span><span style="display:flex;"><span>s/good/&amp; bye/
</span></span></code></pre></div><p>sam 에선 다음과 같은 명령으로 처리할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>/good/c/bad/
</span></span><span style="display:flex;"><span>/good/d
</span></span><span style="display:flex;"><span>/good/a/ bye/
</span></span></code></pre></div><p>처리할 텍스트는 이미 현재텍스트(점)로 설정되므로 별도의 검색 과정이 불필요하게 됩니다.</p>
<p>또한, 다음과 같은 ed 관용구를 sam 에서 사용할 때는 조심하시기 바랍니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1,$s/good/bad/
</span></span></code></pre></div><p>이 명령은 각 라인의 첫 번째 일치 항목만 변경합니다. sam 의 동일한 처리 명령은 전체 파일의 첫 번째 일치 항목만 변경합니다!! 따라서, 올바른 sam 명령은</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x s/good/bad/
</span></span></code></pre></div><p>그러나, 더 명확한 처리 방법은</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>,x/good/ c/bad/
</span></span></code></pre></div><p>sam 은 이처럼 ed 와는 다른 규칙에 따라 처리됩니다.]</p>
<p><a href="#top">:arrow_up:</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="files">Files</h1>
<p>지금까진 단일 파일로 작업했지만, 사실 sam 은 기본적으로 <code>다중 파일 편집기</code> 입니다.</p>
<p>하지만, 한 번에 하나의 파일만 편집할 수 있지만, 어떤 파일이 현재 편집 중인지 구별하기 위한 <code>현재 파일</code> 인지 쉽게 표시하거나 변경할 수 있습니다.
이런 작업 방식을 설명하려면 몇 개의 파일이 포함되어 실행된 sam 이 필요합니다. 이를 수행하는 가장 쉬운 방법은 편집할 Unix 파일 이름의 집합으로 시작하는 방법입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>$ echo *.ms
</span></span><span style="display:flex;"><span>conquest.ms death.ms emacs.ms famine.ms slaughter.ms
</span></span><span style="display:flex;"><span>$ sam -d *.ms
</span></span><span style="display:flex;"><span>-. conquest.ms
</span></span></code></pre></div><p>(기병이 전례의 순서대로 나타나지 않은 것은 유감입니다.^^) sam 에서 출력한 것은 Unix 파일 &ldquo;conquest.ms&rdquo; 파일을 읽었으며 이 파일이 <code>현재파일</code> 임을 나타냅니다. sam 은 파일이 현재파일이 될 때까지 Unix 파일을 읽어들이지 않습니다.</p>
<p><code>n</code> (<em>name</em>)명령은 sam 에서 편집할 모든 파일의 이름을 출력합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>n
</span></span><span style="display:flex;"><span>-. conquest.ms
</span></span><span style="display:flex;"><span>- death.ms
</span></span><span style="display:flex;"><span>- emacs.ms
</span></span><span style="display:flex;"><span>- famine.ms
</span></span><span style="display:flex;"><span>- slaughter.ms
</span></span></code></pre></div><p>파일 이름 목록은 다운로드 모드로 실행한 sam 에서 마우스 버튼 3의 메뉴와 동일하게 사용할 수 있습니다.</p>
<p><code>f</code> (<em>file</em>) 명령은 현재 파일의 이름을 알려줍니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>f
</span></span><span style="display:flex;"><span>-. conquest.ms
</span></span></code></pre></div><p>파일 이름 왼쪽에 있는 문자는 해당 파일에 대한 유용한 정보를 인코딩합니다.</p>
<p>만약, 해당 파일에 대한 편집 윈도우가 열려있다면 빼기(<code>-</code>) 문자는 더하기(<code>+</code>) 문자로 바뀌고, 둘 이상의 편집 윈도우가 열려있다면 별표(<code>*</code>) 문자를 표시합니다.
마침표 (현재텍스트의 또 다른 의미) 문자는 <code>현재파일</code> 임을 표시합니다. sam 의 파일과 관련된 Unix 파일의 내용이 서로 다를 경우엔 작은 따옴표(<code>'</code>) 문자로 변경됩니다.</p>
<p>이것은 파일에 어떤 변화를 직접 일으켜 본다면 더욱 더 분명해집니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1d
</span></span><span style="display:flex;"><span>f
</span></span><span style="display:flex;"><span>’-. conquest.ms
</span></span></code></pre></div><p><code>u</code> 실행 취소 명령으로 파일을 다시 복원하면 작은 따옴표 문자는 다시 사라집니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>u
</span></span><span style="display:flex;"><span>f
</span></span><span style="display:flex;"><span>-. conquest.ms
</span></span></code></pre></div><p><code>f</code> 명령으로 새로운 파일 이름을 제공해 파일 이름을 변경할 수 있습니다 .</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>f pestilence.ms
</span></span><span style="display:flex;"><span>’-. pestilence.ms
</span></span></code></pre></div><p><code>f</code> 명령은 새로운 파일 이름을 항상 출력합니다. 즉, 파일 이름이 이미 제공된 경우, 해당 이름으로 변경하고 이전/이후의 이름에 관계없이 항상 출력합니다.</p>
<p>파일 이름 변경 작업 또한 <code>u</code> 명령으로 실행 취소할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>u
</span></span><span style="display:flex;"><span>f
</span></span><span style="display:flex;"><span>-. conquest.ms
</span></span></code></pre></div><p>sam 이 다운로드 모드 상태로 실행되면 우측 마우스로 표시되는 메뉴에서 원하는 파일을 직접 선택해 현재파일을 직접 변경할 수 있습니다.  <code>sam -d</code> 모드로 실행했다면 <code>b</code> 명령을 사용해 지정한 파일을 현재파일로 선택할 수 있습니다.</p>
<blockquote>
<p>[!IMPORTANT]
버그로 인해 다운로드 모드로 sam 을 실행할 경우, <code>b</code> 명령이 작동하지 않도록 처리합니다. 어떤식으로 처리하든 메뉴를 사용하는 것이 더 편리하고 sam 명령 언어로 현재 파일을 선택하는 방법은 추후 변경될 예정이기 때문에 이 버그는 아직까지 수정되지 않았습니다.</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>b emacs.ms
</span></span><span style="display:flex;"><span>-. emacs.ms
</span></span></code></pre></div><p>다시 한 번 말하지만, sam 은 Unix 파일 &ldquo;emacs.ms&rdquo; 를 최초로 읽었기 때문에 해당 파일 이름을 출력합니다. (실제 암시적으론 <code>f</code> 명령을 실행함)</p>
<p>만약, sam 이 알지 못하는 파일 이름을 <code>b</code> 명령으로 요청한다는 것은 <code>오류</code> 지만, <code>B</code> (대문자)명령을 사용하면 sam 의 파일 이름 목록을 새로 추가한 파일로 준비한 후, 현재파일로 만듭니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>b flood.pic
</span></span><span style="display:flex;"><span>?no such file ‘flood.pic’
</span></span><span style="display:flex;"><span>B flood.pic
</span></span><span style="display:flex;"><span>-. flood.pic
</span></span><span style="display:flex;"><span>n
</span></span><span style="display:flex;"><span>- conquest.ms
</span></span><span style="display:flex;"><span>- death.ms
</span></span><span style="display:flex;"><span>- emacs.ms
</span></span><span style="display:flex;"><span>- famine.ms
</span></span><span style="display:flex;"><span>-. flood.pic
</span></span><span style="display:flex;"><span>- slaughter.ms
</span></span></code></pre></div><p><code>b</code> 와 <code>B</code> 명령 모두 파일 이름에 대한 목록을 허용합니다. <code>b</code> 명령은 단순히 파일 이름 목록의 첫 번째 파일만 로드하지만, <code>B</code> 명령은 모든 파일을 로드합니다.</p>
<p>파일 이름 목록은 한 라인에 한번에 모두 입력할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>B devil.tex satan.tex 666.tex emacs.tex
</span></span></code></pre></div><p>또는, 다음과 같이 Unix 프로그램을 이용해 생성할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>B &lt;echo *.tex
</span></span></code></pre></div><p>위에서 사용한 구문 형식은 <code>echo</code> 라는 Unix 프로그램이 반드시 필요합니다. 왜냐하면, sam 은 쉘의 파일 이름 대체에서 사용하는 메타 문자를 전혀 이해하지 못하므로,
<code>B *.tex</code> 구문은 <code>*.tex</code> 라는 단일 파일 이름으로 로드하려 시도합니다. ( <code>&lt;</code> 입력 재지정 메타 문자는 물론 sam 의 <code>&lt;</code> 명령으로 인식합니다.)</p>
<p>echo 프로그램은 <code>B</code> 명령으로 실행할 수 있는 유일한 Unix 프로그램이 아닙니다. 예를 들어,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>B &lt;grep -l Emacs *
</span></span></code></pre></div><p>이 명령은 &ldquo;Emacs&rdquo; 를 포함한 파일만 sam 파일 이름 목록으로 로드합니다.</p>
<p>마지막으로 매우 특수한 경우로, 파일 이름을 별도로 지정하지 않은 <code>B</code> 명령은 sam 에게 파일 이름이 비어있는 새로운 파일을 만듭니다.</p>
<p><code>B</code> 명령의 반대 (보수) 명령은 <code>D</code> 명령입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>D devil.tex satan.tex 666.tex emacs.tex
</span></span></code></pre></div><p>sam 의 파일 이름 목록에서 지정한 파일을 삭제합니다. (실제 Unix 파일을 삭제하는 것이 아님) 파일 이름이 없는 <code>D</code> 명령은 sam 에게 현재 파일을 제거하도록 합니다 .</p>
<p>현재 편집중인 파일을 Unix 파일과 연관시키는 세 가지 다른 명령이 있습니다.</p>
<p><code>w</code> (<em>write</em>) 명령은 파일을 디스크의 Unix 파일로 저장합니다. 만약 별다른 인수가 없다면 전체 파일을 sam 의 현재파일과 연결된 Unix 파일에 저장합니다. (기본 주소가 현재텍스트가 아닌 유일한 명령임)</p>
<p>물론, 다음과 같이 명확한 구문을 사용해 1번 라인부터 2번 라인까지를 저장할 범위 주소와 다른 파일 이름을 함께 지정해 저장할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1,2w /tmp/revelations
</span></span><span style="display:flex;"><span>/tmp/revelations: #44
</span></span></code></pre></div><p>sam 은 파일 이름과 파일에 기록된 문자 수로 응답합니다. 다운로드 모드 상태의 sam 에선 버튼 3 메뉴의 쓰기 (Write) 명령은 인수없이 사용한 <code>w</code> 명령과 그 기능이 동일합니다.</p>
<p>또 다른 두 명령인 <code>e</code> (<em>edit</em>) 와 <code>r</code> (<em>read</em>) 명령은 Unix 파일에서 현재 편집중인 현재파일로 데이터를 읽어옵니다.</p>
<p><code>e</code> 명령은 현재 파일을 먼저 지운 후, 명명된 파일에서 데이터를 읽고, (또는, 명시적으로 제공되지 않은 경우 현재 파일의 이전 파일 이름을 사용) 파일 이름을 기억합니다.</p>
<p>이것은 <code>B</code> 명령과 매우 유사하지만 읽어온 정보를 새로운 파일 대신 현재파일에 저장합니다. 따라서, 파일 이름이 없는 <code>e</code> 명령은 sam 의 파일을 Unix 파일의 복사본으로 업데이트할 수 있는 쉬운 방법입니다.</p>
<blockquote>
<p>[!TIP]
[ed와 달리 <code>e</code> 명령은 파일이 수정되었더라도 별도로 불평하지 않습니다. 잘못된 경우, 실행 취소할 수 있는 것을 보호하는 것은 sam 의 처리 원칙이 아닙니다.]</p></blockquote>
<p>전체 텍스트를 교체하는 작업이므로 <code>e</code> 명령은 별도의 주소를 사용하지 않습니다.</p>
<p><code>r</code> 명령은 <code>e</code> 명령과 비슷하지만, 현재파일을 지우지 않습니다. Unix 파일의 텍스트가 현재텍스트를 대체하거나 주소가 지정된다면</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>r emacs.ms
</span></span></code></pre></div><p>본질적으로 다음과 같은 명령과 동일한 효과가 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>&lt;cat emacs.ms
</span></span></code></pre></div><p><code>r</code> 및 <code>w</code> 명령은 현재파일에 이미 정의된 (기억된) 파일 이름이 없을 경우, 파일 이름을 새롭게 설정합니다. <code>e</code> 명령은 파일에 이미 이름이 있더라도 지정한 이름으로 설정합니다.</p>
<p>텍스트 대신 파일 이름 목록에 대해 반복 작업을 처리하는 <code>x</code> 명령과 유사한 명령이 있습니다. 따라서, <code>X</code> (대문자) 명령은 이해하기 쉽습니다.</p>
<p>그것은 <code>x</code> 명령과 <code>X/pattern/command</code> 같이 사용 구문이 완전히 동일합니다. (보완적인 명령은 <code>Y</code> 이며, <code>y</code> 명령과 유사합니다.)</p>
<p>이 명령의 사용 효과는 파일 이름 목록 (즉, <code>f</code> 명령으로 출력된 라인) 중 패턴과 일치하는 각각의 파일 이름에 대해 특정 명령을 실행하는 것입니다.</p>
<p>예를 들어, 파일 이름 목록에서 작은 따옴표 문자는 수정된 파일을 의미하므로,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>X/’/ w
</span></span></code></pre></div><p>이 명령은 파일 내용이 변경된 파일만 Unix 파일에 저장합니다.</p>
<p>다음은 조금 긴 명령의 예제입니다. sam 의 파일 이름 목록 중 C소스 파일내에 &ldquo;variable&rdquo; 을 포함한 라인을 출력합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gdscript3" data-lang="gdscript3"><span style="display:flex;"><span>X<span style="color:#f92672">/</span>\<span style="color:#f92672">.</span>c<span style="color:#f92672">$/</span> ,x<span style="color:#f92672">/</span>variable<span style="color:#f92672">/+-</span>p
</span></span></code></pre></div><p><code>f</code> 명령을 사용해 &ldquo;variable&rdquo; 이 포함된 라인에 대한 보다 자세한 정보를 출력할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gdscript3" data-lang="gdscript3"><span style="display:flex;"><span>X<span style="color:#f92672">/</span>\<span style="color:#f92672">.</span>c<span style="color:#f92672">$/</span> ,g<span style="color:#f92672">/</span>variable<span style="color:#f92672">/</span> {
</span></span><span style="display:flex;"><span>   f
</span></span><span style="display:flex;"><span>   ,x<span style="color:#f92672">/</span>variable<span style="color:#f92672">/+-</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>	p
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>여기서 사용한 <code>g</code> 명령은 &ldquo;variable&rdquo; 을 포함한 파일 이름만 출력되도록 보장합니다. (그러나 sam 은 명령에서 읽은 파일 이름을 출력하므로 문제를 혼동할 수 있습니다)</p>
<p><code>=</code> 명령은 해당 파일에 &ldquo;variable&rdquo; 이 나타나는 라인의 위치를 표시하고 <code>p</code> 명령은 해당 라인 (<code>+-</code>) 을 출력합니다.</p>
<p><code>D</code> 명령은 <code>X</code> 명령의 처리 대상으로 사용하기 편리합니다. 다음 예제는 파일 목록에 &ldquo;variable&rdquo; 을 포함하지 않은 모든 C파일을 삭제합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-gdscript3" data-lang="gdscript3"><span style="display:flex;"><span>X<span style="color:#f92672">/</span>\<span style="color:#f92672">.</span>c<span style="color:#f92672">$/</span> ,v<span style="color:#f92672">/</span>variable<span style="color:#f92672">/</span> D
</span></span></code></pre></div><p><code>X</code> 명령에 별도의 인수가 제공되지 않으면 명령 (기본값은 <code>f</code>) 은 모든 파일을 대상으로 실행되므로 다음과 같은 명령은</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>X D
</span></span></code></pre></div><p>새로운 작업 시작을 위해 sam 파일 이름 목록을 깨끗이 정리합니다. 그러나, 이젠 더 이상의 작업을 처리하지 않고 그냥 종료합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>q
</span></span><span style="display:flex;"><span>$
</span></span></code></pre></div><p>일부 파일 관련 조작 명령은 실행 취소할 수 있습니다. <code>f</code>, <code>e</code> 또는 <code>r</code> 명령을 실행 취소한다면 명령 이전 상태로 복원됩니다.</p>
<p>하지만, 파일 상태에 따라 다르겠지만 <code>w</code>, <code>B</code> 및 <code>D</code> 명령은 실행 취소할 수 없습니다. 당연히 <code>q</code> 명령도 마찬가지입니다.</p>
<p><a href="#top">:arrow_up:</a></p>

        </section>
        <div class="post-tags">
          
          
          <nav class="nav tags">
            <ul class="tags">
              
              <li><a href="/tags/editor">editor</a></li>
              
            </ul>
          </nav>
          
          
        </div>
      </div>

      
      
    </div>

    </article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2025  ©XenoStream.com  |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>

</div>
    </body>
</html>
